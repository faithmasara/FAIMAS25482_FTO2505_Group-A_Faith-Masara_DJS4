<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>PodcastApp</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: { extend: { boxShadow: { card:'0 1px 1px rgb(0 0 0 / .05), 0 6px 16px rgb(0 0 0 / .06)' } } }
    }
  </script>

  <!-- React + Babel -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Link your local genres (works for ESM or window var) -->
  <script type="module" src="./data.js"></script>
</head>
<body class="bg-gray-50 text-gray-900 antialiased">
  <!-- Header (kept) -->
  <nav class="border-b bg-white">
    <div class="max-w-7xl mx-auto px-4 md:px-6 lg:px-8 h-14 flex items-center justify-between">
      <div class="flex items-center gap-2">
        <svg width="20" height="20" viewBox="0 0 24 24" class="text-gray-800">
          <path fill="currentColor" d="M12 2a7 7 0 0 0-7 7a6.99 6.99 0 0 0 4.5 6.53V21a1 1 0 1 0 2 0v-4h3v4a1 1 0 1 0 2 0v-5.47A7 7 0 0 0 12 2Zm0 2a5 5 0 0 1 2 9.58V15h-4v-1.42A5 5 0 0 1 12 4Z"/>
        </svg>
        <span class="font-semibold">PodcastApp</span>
      </div>
      <div class="flex items-center gap-5">
        <svg width="20" height="20" viewBox="0 0 24 24" class="text-gray-500">
          <path fill="currentColor" d="M10 2a8 8 0 1 1 0 16a8 8 0 0 1 0-16m8.32 14.9l3.39 3.38l-1.41 1.42l-3.39-3.39A10 10 0 1 1 10 0a10 10 0 0 1 8.32 16.9"/>
        </svg>
        <div class="w-7 h-7 rounded-full bg-gray-200 border"></div>
      </div>
    </div>
  </nav>

  <main class="max-w-7xl mx-auto px-4 md:px-6 lg:px-8 py-6">
    <!-- Controls: Filter, Sort, Search (kept the 'Filter by:' wording) -->
    <div class="mb-4 grid gap-3 md:grid-cols-[auto,200px,220px,1fr] items-center">
      <span class="text-sm text-gray-600">Filter by:</span>

      <!-- Genre dropdown (single select to keep screenshot vibes; multi-select not required) -->
      <select id="genreSelect" class="border rounded-md px-3 py-2 bg-white text-sm">
        <option value="all">All Genres</option>
      </select>

      <!-- Sort dropdown: 'Recently Updated' + A–Z/Z–A -->
      <select id="sortSelect" class="border rounded-md px-3 py-2 bg-white text-sm">
        <option value="newest">Recently Updated</option>
        <option value="title-asc">Title A–Z</option>
        <option value="title-desc">Title Z–A</option>
      </select>

      <!-- Search input -->
      <div class="flex items-center gap-2">
        <input
          id="searchInput"
          type="search"
          placeholder="Search titles…"
          class="w-full border rounded-md px-3 py-2 text-sm bg-white"
        />
      </div>
    </div>

    <!-- Grid root -->
    <div id="root"></div>

    <!-- Pagination controls -->
    <div id="pagination-root" class="mt-6"></div>
  </main>

  <!-- Optional Web Component (kept, not required for render path) -->
  <script type="module" src="./podcast-preview.js"></script>

  <!-- React App -->
  <script type="text/babel" data-presets="env,react">
    const { useEffect, useMemo, useReducer, useState } = React;

    /** @typedef {{id:number,title:string,genres:number[]|string[],updated:string,seasons?:any[]|number,description?:string}} RawPodcast */

    /** Human-friendly "Updated …" */
    const fmtUpdated = (iso) => {
      const d=new Date(iso), diff=Date.now()-d.getTime();
      const m=Math.floor(diff/60000), h=Math.floor(m/60), day=Math.floor(h/24);
      if (day>7) return `Updated ${d.toLocaleDateString(undefined,{year:'numeric',month:'long',day:'numeric'})}`;
      if (day>=1) return `Updated ${day} day${day>1?'s':''} ago`;
      if (h>=1) return `Updated ${h} hour${h>1?'s':''} ago`;
      if (m>=1) return `Updated ${m} minute${m>1?'s':''} ago`;
      return 'Updated just now';
    };

    /**
     * Load local genres from data.js (ESM export or window var), fallback to API.
     * @returns {Promise<Array<{id:number,title:string}>|null>}
     */
    async function loadGenres() {
      // Try ESM import & common names
      try{
        const mod = await import('./data.js');
        let arr = mod.default ?? mod.GENRES ?? mod.genres ?? window.GENRES ?? window.genres;
        if (typeof arr === 'function') arr = arr();
        if (Array.isArray(arr) && arr.length) {
          return arr.map(g => ({ id:Number(g.id??g.ID??g.value), title:String(g.title??g.name??g.label) }));
        }
      }catch {}
      // Fallback to API
      try{
        const r = await fetch('https://podcast-api.netlify.app/genres');
        if (r.ok) return await r.json();
      }catch {}
      return null;
    }

    /** Domain model to normalize API list/detail shapes (SOLID: SRP). */
    class Podcast {
      /** @param {RawPodcast} s */
      constructor(s){
        this.id = s.id;
        this.title = s.title || 'Podcast Title';
        this.genres = s.genres || [];
        this.updated = s.updated || new Date().toISOString();
        this.seasonCount = Array.isArray(s.seasons) ? s.seasons.length : (s.seasons || 0);
        this.seasons = Array.isArray(s.seasons) ? s.seasons : [];
        this.description = s.description || '';
        this.image = ''; // keep grey placeholder for visual consistency
      }
    }

    /** Card (kept visually consistent with your design) */
    const Card = ({ title, seasons, genres, updated, onClick }) => (
      <button className="text-left" onClick={onClick}>
        <article className="bg-white border rounded-xl p-4 shadow-card hover:shadow-md transition">
          <div className="w-full aspect-[4/3] rounded-lg bg-gray-400/60 flex items-center justify-center text-white font-semibold">
            Podcast Cover
          </div>
          <h3 className="mt-3 font-bold text-base text-gray-900">{title}</h3>
          <div className="mt-1 text-sm text-gray-600 flex items-center gap-2">
            <svg width="16" height="16" viewBox="0 0 24 24" className="text-gray-500">
              <path fill="currentColor" d="M7 3v2H5a2 2 0 0 0-2 2v2h18V7a2 2 0 0 0-2-2h-2V3h-2v2H9V3zM3 19a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V11H3z"/>
            </svg>
            <span>{seasons} season{seasons===1?'':'s'}</span>
          </div>
          <div className="mt-2 flex flex-wrap gap-2">
            {genres.slice(0,2).map((g,i)=>(
              <span key={i} className="inline-flex text-xs px-2 py-1 bg-gray-100 border rounded-full text-gray-800">{g}</span>
            ))}
          </div>
          <p className="mt-3 text-sm text-gray-500">{fmtUpdated(updated)}</p>
        </article>
      </button>
    );

    const Pill = ({ children }) => (
      <span className="inline-flex text-xs px-2 py-1 bg-gray-100 border rounded-full">{children}</span>
    );

    /** Details modal */
    const Modal = ({ open, onClose, children }) => {
      if (!open) return null;
      return (
        <div className="fixed inset-0 z-50 flex items-start md:items-center justify-center p-4" role="dialog" aria-modal="true">
          <div className="absolute inset-0 bg-black/40" onClick={onClose}></div>
          <section className="relative w-full max-w-3xl bg-white rounded-2xl shadow-card overflow-hidden">
            <button onClick={onClose} className="absolute top-3 right-3 w-9 h-9 rounded-full border hover:bg-gray-50" aria-label="Close">✕</button>
            <div className="p-6">{children}</div>
          </section>
        </div>
      );
    };

    const Details = ({ item, genreLookup }) => {
      const names = (item.genres||[]).map(id=> genreLookup[id] || `Genre ${id}`);
      return (
        <div className="grid gap-6 md:grid-cols-[260px,1fr]">
          <div className="bg-gray-400/60 rounded-xl aspect-[1/1] flex items-center justify-center text-white font-semibold">Large Cover Image</div>
          <div>
            <h2 className="text-2xl font-bold mb-2">{item.title}</h2>
            <p className="text-gray-700">{item.description || '—'}</p>
            <div className="flex flex-wrap gap-2 mt-3">{names.map(n=> <Pill key={n}>{n}</Pill>)}</div>
            <p className="text-sm text-gray-500 mt-3">{fmtUpdated(item.updated)}</p>
          </div>
          <div className="md:col-span-2 border-t pt-4">
            <h3 className="font-semibold text-lg mb-3">Seasons</h3>
            <ul className="space-y-3">
              {item.seasons.map((s,i)=>(
                <li key={i} className="flex items-center justify-between border rounded-xl p-4">
                  <div>
                    <p className="font-semibold">{s.title || `Season ${i+1}`}</p>
                    <p className="text-sm text-gray-600">{s.description || '—'}</p>
                  </div>
                  <span className="text-sm text-gray-700">{(s.episodes||[]).length} episodes</span>
                </li>
              ))}
            </ul>
          </div>
        </div>
      );
    };

    /** ---------- STATE ---------- */

    const PAGE_SIZE = 12;

    const initialState = {
      shows: [],        // all shows (Podcast[])
      genres: [],       // [{id,title}]
      query: '',        // search text
      sort: 'newest',   // 'newest' | 'title-asc' | 'title-desc'
      genreFilter: 'all', // single genre id or 'all'
      page: 1,          // current page (1-based)
      detail: null,     // selected Podcast for modal
      loading: true,    // initial loading for shows
    };

    /**
     * @typedef {{
     *  type:string,
     *  payload?:any
     * }} Action
     * Centralised reducer to keep controls in sync.
     * @param {typeof initialState} state
     * @param {Action} action
     */
    function reducer(state, action){
      switch(action.type){
        case 'setData':
          return { ...state, shows: action.payload.shows, genres: action.payload.genres ?? state.genres, loading:false };
        case 'setGenres':
          return { ...state, genres: action.payload };
        case 'query':
          return { ...state, query: action.payload }; // do not reset page; we clamp later
        case 'sort':
          return { ...state, sort: action.payload };
        case 'filterGenre':
          return { ...state, genreFilter: action.payload };
        case 'page':
          return { ...state, page: action.payload };
        case 'detail':
          return { ...state, detail: action.payload };
        default:
          return state;
      }
    }

    /** ---------- APP ---------- */

    const App = () => {
      const [state, dispatch] = useReducer(reducer, initialState);

      // Load genres (local first) + shows
      useEffect(()=>{
        let alive = true;
        (async()=>{
          const local = await loadGenres();
          if (alive && local) dispatch({ type:'setGenres', payload: local });

          try{
            const r = await fetch('https://podcast-api.netlify.app/shows');
            if (r.ok){
              const list = (await r.json()).map(s=> new Podcast(s));
              // default order: Recently Updated
              list.sort((a,b)=> new Date(b.updated)-new Date(a.updated));
              if (alive) dispatch({ type:'setData', payload:{ shows:list } });
            } else {
              if (alive) dispatch({ type:'setData', payload:{ shows:[] } });
            }
          }catch{
            if (alive) dispatch({ type:'setData', payload:{ shows:[] } });
          }

          // If no local genres, try API (fallback)
          if (!local) {
            try{
              const g = await fetch('https://podcast-api.netlify.app/genres');
              if (alive && g.ok) dispatch({ type:'setGenres', payload: await g.json() });
            }catch{}
          }
        })();
        return ()=> { alive=false; };
      },[]);

      const genreLookup = useMemo(()=> Object.fromEntries((state.genres||[]).map(g=>[g.id,g.title])), [state.genres]);

      /** Derived list: filter → search → sort (keep pagination state intact) */
      const derived = useMemo(()=>{
        const q = state.query.trim().toLowerCase();
        let arr = state.shows;

        // Filter by genre (single select)
        if (state.genreFilter !== 'all') {
          const gid = Number(state.genreFilter);
          arr = arr.filter(s => (s.genres||[]).includes(gid));
        }

        // Search in title (contains)
        if (q) {
          arr = arr.filter(s => (s.title||'').toLowerCase().includes(q));
        }

        // Sort
        const sorted = [...arr];
        if (state.sort === 'newest') {
          sorted.sort((a,b)=> new Date(b.updated)-new Date(a.updated));
        } else if (state.sort === 'title-asc') {
          sorted.sort((a,b)=> a.title.localeCompare(b.title));
        } else if (state.sort === 'title-desc') {
          sorted.sort((a,b)=> b.title.localeCompare(a.title));
        }

        return sorted;
      }, [state.shows, state.genreFilter, state.query, state.sort]);

      // Clamp page if filters reduce length
      const totalPages = Math.max(1, Math.ceil(derived.length / PAGE_SIZE));
      const page = Math.min(state.page, totalPages);
      const start = (page-1)*PAGE_SIZE;
      const visible = derived.slice(start, start + PAGE_SIZE);

      // Wire native selects/inputs (keep DOM exactly as declared)
      useEffect(()=>{
        const genreSel = document.getElementById('genreSelect');
        const sortSel = document.getElementById('sortSelect');
        const searchInput = document.getElementById('searchInput');
        if (!genreSel || !sortSel || !searchInput) return;

        // populate genres
        genreSel.innerHTML = '<option value="all">All Genres</option>';
        state.genres.forEach(g=>{
          const o=document.createElement('option'); o.value=g.id; o.textContent=g.title;
          genreSel.appendChild(o);
        });
        genreSel.value = state.genreFilter;
        sortSel.value = state.sort;
        searchInput.value = state.query;

        const onGenre = e => dispatch({ type:'filterGenre', payload: e.target.value });
        const onSort = e => dispatch({ type:'sort', payload: e.target.value });
        const onSearch = e => dispatch({ type:'query', payload: e.target.value });

        genreSel.addEventListener('change', onGenre);
        sortSel.addEventListener('change', onSort);
        searchInput.addEventListener('input', onSearch);

        return ()=>{
          genreSel.removeEventListener('change', onGenre);
          sortSel.removeEventListener('change', onSort);
          searchInput.removeEventListener('input', onSearch);
        };
      }, [state.genres, state.genreFilter, state.sort, state.query]);

      return (
        <>
          {/* Grid */}
          {state.loading && state.shows.length===0 ? (
            <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
              {Array.from({length:8}).map((_,i)=>(
                <article key={i} className="bg-white border rounded-xl p-4 shadow-card animate-pulse">
                  <div className="w-full aspect-[4/3] rounded-lg bg-gray-200"></div>
                  <div className="mt-3 h-4 bg-gray-200 rounded w-1/2"></div>
                  <div className="mt-2 h-3 bg-gray-200 rounded w-1/3"></div>
                  <div className="mt-2 flex gap-2">
                    <div className="h-5 bg-gray-200 rounded-full w-16"></div>
                    <div className="h-5 bg-gray-200 rounded-full w-20"></div>
                  </div>
                  <div className="mt-3 h-3 bg-gray-200 rounded w-24"></div>
                </article>
              ))}
            </div>
          ) : derived.length === 0 ? (
            <div className="py-16 text-center text-gray-600">No podcasts match your criteria.</div>
          ) : (
            <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
              {visible.map(p=>{
                const names = (p.genres||[]).map(id => genreLookup[id] || `Genre ${id}`);
                return (
                  <Card
                    key={p.id}
                    title={p.title}
                    seasons={p.seasonCount}
                    genres={names}
                    updated={p.updated}
                    onClick={async ()=>{
                      try{
                        const r = await fetch(`https://podcast-api.netlify.app/id/${p.id}`);
                        if (r.ok) { dispatch({ type:'detail', payload: new Podcast(await r.json()) }); return; }
                      }catch{}
                      dispatch({ type:'detail', payload: p });
                    }}
                  />
                );
              })}
            </div>
          )}

          {/* Pagination */}
          <div className="mt-6 flex items-center justify-between">
            <p className="text-sm text-gray-600">
              Showing <span className="font-medium">{derived.length ? start+1 : 0}</span>–<span className="font-medium">{Math.min(start+PAGE_SIZE, derived.length)}</span> of <span className="font-medium">{derived.length}</span>
            </p>
            <div className="flex items-center gap-2">
              <button
                className="px-3 py-2 text-sm border rounded-md disabled:opacity-50"
                onClick={()=> dispatch({ type:'page', payload: Math.max(1, page-1) })}
                disabled={page<=1}
              >Prev</button>
              <span className="text-sm text-gray-700">Page {page} / {totalPages}</span>
              <button
                className="px-3 py-2 text-sm border rounded-md disabled:opacity-50"
                onClick={()=> dispatch({ type:'page', payload: Math.min(totalPages, page+1) })}
                disabled={page>=totalPages}
              >Next</button>
            </div>
          </div>

          {/* Modal */}
          <Modal open={Boolean(state.detail)} onClose={()=> dispatch({ type:'detail', payload: null })}>
            {state.detail && <Details item={state.detail} genreLookup={genreLookup} /> }
          </Modal>
        </>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
